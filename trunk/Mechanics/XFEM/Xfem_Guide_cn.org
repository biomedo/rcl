# -*- org -*-

# Time-stamp: <2011-06-17 15:57:03 Friday by lian>

#+OPTIONS: ^:nil author:nil timestamp:nil creator:nil
* XFEM程序的读书笔记
  SCHEDULED: <2011-01-27 Thu>
  1. xFiniteElement這個類的理解，這個類的作用就是輸入一個mEntity對象，他就能幫你返回對應的xValueKey， 記住不管怎麼樣，不管輸入的什麼樣的對象點，線，面，體對象等（dim=0，1，2，3），他都會幫你返回 點對象的ValueKey,也就是說那些對象都被最終分解為點對象，因為有限元計算關心的是節點信息，因此經過這類他就會幫你返回網格中節點對應的xValueKey，而通過xValueManager就可以獲得對應的xDoubleValue。 而整個網格對應的xDoubleValue和xValueKey都是通過DeclareInterpolation來創建的。
  2. xClassRegion這個類可以返回xMesh（mMesh）網格中的點，線，面，體的集合，通過這些對象的ntity_id，注意這個entity_id，其實就是在gmsh生成網格時對應的physical index。
  3. xField這個類是連接了xSpace和實際的xDoubleValueManager，因此我們直接可以通過xField.beginValues(mEntity)和xField.endValues(mEntity）來返回mEntity對應的xDoubleValue，不管mEntity的類型是點線面體。同理xField.beginFcts(mEntity） 返回對應的shape function。
  4. xAssembler類用來集成全局剛度矩陣和全局載荷向量，在該類中分為集成矩陣還是向量，若是集成矩陣時要提供I，J，Value信息，如果要集成載荷陣列則要提供I, Value信息。並且實際上I，J信息的提供只是需要一個在整體剛度矩陣中的位置信息即可，在當前XFEM程序中不採用整型數來編號，而是通過每個節點的xDoubleValue的指針，也就是xDoubleValueManager中的Iterator來進行。
  5. xSpaceLagrange,xSpaceComposite,xSpaceFiltered等对象的主要作用是获取形函数（Fcts）和键值的（femKey）。核心工作就是你可以输入一个mEntity* e，注意这个Entity可以是体，面，线，点各种对象，他会根据定义的Space的自由度空间，返回对应节点的ValueKey以及Function。也就是输入一个从大的对象返回对应点对象对应的节点自由度信息.具体的实现参见代码xSpaceLagrange::getKeys(mEntity* e, femKeys* keys)，其中涉及了对各种不同的几何对象如何获取对应几何对象的基本节点，然后再根据空间自由度，向量场还是标量场，来生成对应的自由度所对应的xValueKey。所以仅仅是生成xValueKey。
  6. 当看到xEval是就是重载了括号运算符的一个函数对象，返回值的类型就是模板提供的参数。比如xEvalConst表示返回常数,xEvalFctAtPoint返回给定的函数在某点的值；xEvalUnary或者xEvalBinary返回指定的单一参数或者二参数谓词的返回值，也就是计算指定谓词的返回值。 xValOperator and xValOperator数值操作运算符。
  7. xEval, xEvalConst, xEvalFctAtPoint, xEvalUnary, xEvalBinary,当看到这些函数时，要在浅意识有几点认识。第一，只有xEval字样就表示要进行一个Evaluation,这个求值，是建立在给定每个单元的xGeoElm m_appro, m_eteg参数然后返回一个计算的值，计算返回值的类型就是xEval<T>中的T所指定的参数；第二，如果看到xEvalUnary and xEvalBinary就意味着首先要对在构造函数中传入的两个xEval类型的派生对象进行求值运算，然后他们分别求值运算的结果，作为Unary或者Binary的参数，在进行一次Unary或者Binary操作符的运算，得到的结果作为xEvalBinary求值运算的返回值。比如xEvalBinary< xMult<xTensor4, xTensor2, xTensor2> > eval_stress(hooke, eval_strain);，这条语句的意思就是说，要进行一次求值运算，首先对构造函数传入的参数hook，和eval_strain分别进行他们对应的operator()(xGeoElement* appro, xGeoElement* integ, returntype& res)进行求值运算，然后他们的返回的计算结果，分别是xTensor4和xTensor2类型的，他们分别作为二维谓词xMult的两个参数，再进行求值运算，得到的结果作为最终的返回值。因此可以看出整个这个xEvalBinary的返回值类型应该是xMult<xTensor4, xTensor2, xTensor2>中最后一个参数类型，而xMult<xTensor4, xTensor2, xTensor2>头两个参数的类型就分别是hooke和eval_strain的返回值类型。因此我们可以说xEvalBinary,或者xEvalUnary的意思就是首先进行xEval求值运算，然后返回值在进行Binary或者Unary操作符对应的运算。

  8. 一些概念，对于每个节点都有xValueKey xDoubleValue ShapeFuction,通过xfield来管理，xvaluemanager。对于组装整体刚度矩阵，需要对每个单元进行积分，求解其单元刚度矩阵，而后装配到整体刚度矩阵。对每个进行积分求解单元刚度矩阵，就需要遍历每个单元，每个单元在遍历其中的节点来进行积分。
  9. xMesh中的xVertex对应的就是节点的几何对象，其中的Id就是gmsh文件中的nodeid因此在输出的dcl.dbg文件中也就是xDoubleManager中输出的调试信息的Enti id号。这样一旦出现问题时，可以对照gmsh和dcl.dbg文件来找到问题。
  10. mEntity e_integ and e_appro; xGeoElement geo_integ and geo_appro; 区别就是当一个单元被加强时，zerolevel与单元相交，这个时候整个单元叫做e_appro and geo_appro，而那些小的subelements我们叫做e_Integ and geo_integ，这个小的单元是用来获取积分点然后进行积分的。也就是说对整个大的单元的积分，转变成了对小的单元的积分的和。这样在每个小单元内部材料的特性就是一致的。一个大的单元有几个小的sub单元构成，但是记住一条规则小的单元的某些在大的单元中间节点上不存在shapefunction，因为这些sub-element只是用来积分更加准确，实际上估计空间中并不存在这些自由度。这些小的子单元和大的单元享有共同形函数，但是他们有自己的积分点和Jacbian行列式。具体的积分点是通过xGeoElement::getUVW来获取的。如果有获取常规坐标下的积分点要用getXYZ，遍历积分点可以通过for(int k = 0; k < nb; k++)geo_integ->setUVW(k);
  11. 如何xspace类型是scalar比如温度，则求得的温度场和场的Gradient操作分别是double和xVector类型;如果xspace 的类型是Vector比如位移场，则求得的位移场以及场的Gradient操作分别为xVector和xTensor2。
  12. xFormBiLinear 是用来组装左侧的刚度矩阵的，而xFormLinear是用来生成对应的载荷阵列的，也就是右侧的向量。如何将双线性形式和线性形式组装到对应的矩阵？通过Assemble这个函数就可以将对应的线性和双线形式组装到对应的矩阵和向量中。这个函数是重载函数，有多种版本形式.
  13. Assemble双线性形式的程序流程如下：首先要确定你的test function的估计函数和你的shapefunction是否一致，这里可以指定不同的函数空间，对于常规固体力学问题往往采用伽辽金法来建立有限元格式，因此test function的估计空间和求解的估计空间是一致的。在程序中通过参数test and trial来进行区分，如果选取一致那么就属于加辽金法。首先遍历你输入的积分区域（一般可是边，面，体），这样程序实际就是用来处理积分区域中的每个子区域。对于每个小的子区域，也就是一条边，一个面，一个体，程序中的变量就是e_integ，另外就是获取估计函数，因为在xfem中需要对一个有两种材料的单元进行积分，而这个单元就是通过levelset来分割的，因此我们要对这种单元进行分割，然后分别对两侧积分，要注意这只是一种积分策略，实际上我们的估计空间中根本不存在这样两个子单元，而只有整个单元，因此对这样的子单元积分时就要用到包含这个子单元的大的单元的形函数来积分。这样这个积分对象的形函数就不是自身节点对应的形函数了。所以这就是为什么在程序中经常看到有e_integ和e_appro，分别表示就是积分对象以及这个积分对象的估计函数。这样对于每个小的子区域，我们可以通过xFiniteElement这个对象获得相应的Shape Functions，这样就获得对应的刚度矩阵了，比如对于一个二维三角形单元区域，有六个自由度，如果加上加强节点就有12个自由度，这样组合出来对应就是一个12X12的矩阵，矩阵每个元素都对应两个下标，这样你能标定把每个元素按照他们在整体刚度矩阵中的位置，组装上去了。要注意两点，第一即使是对于一个单元里面的subdomain进行积分，那么形函数个数取决于单元区域，而不是取决于subdomain，我们只是从subdomain上获得准去的材料特性以及高斯积分点，这样即使是对于这个比自己小的subdomain，那么刚度矩阵仍然是12X12大小的。s
  14. xFormBiLinear是如何工作的呢？他的工作非常简单就是当你给我subdomain对象即e_integ以及对应的估计函数对象e_appro，以及对应的形函数，他就会对每个高斯积分点处刚度矩阵就行累加，获得最终的subdomain对整体刚度矩阵的贡献。主要在xFormBiLinear中，在对每个高斯积分点积分之前，它都会把对应的高斯积分点的坐标放置在xGeoElem(e_appro)中，这样就方便我们调用了。但是对于每个高斯积分点如何积分呢，是采用双线性形式，但是双线性形式格式是什么样的呢？利用C++语言中的虚拟函数这样我们就从xFormBiLinear中实现派生了大量的其它子类，比如xFormBiLinearWithLaw, xFormBiLinearWithoutLaw等。
  15. xFormBiLInearWithoutlaw中accumulate_png是首先返回在某个积分点处各个形函数对应的值（如何有Operator，就应用那个operator，一般是gradient操作符），分别对左项和右侧项执行这个操作，叫做values_left, and values_right。获取该高斯积分点的权值和对应的雅阁比行列式的值wdet，然后将获取的values_left 12和values_right 12，分别相乘并乘以wdet，这样最终就获取了，12X12的刚度矩阵。
  16. 关于如何从一个Entity访问与其相关的Entity，比如从节点访问和节点相连的单元。mEntity* e; e->size(level); e 是一个基类指针，可以指向vertex，edge，face，volume等，level表示想获取的对象的size，比如0获取当前对象所包含的点的个数，1表示想当前对象包含的线的个数，同理2表示面，3表示体；如果当前对象是点，想获取的对象的类型是面，那么这是他就直接给你返回与这个点相连的面的个数。
  17. void fillFieldBidon( xEegion& reg, xField &field, xEval<xTensor2> & 
  eval_stress){

  for(xIter it=reg.begin(0); it!=reg.end(0); ++it){
  mEntity *e = *it;
  mVertex *v = (mVertex *) e;

  int nelem=e->size(2);
  double value=0.;

  for(int i=0;i<nelem;++i){
  mEntity *elem=e->get(2,i);
  xGeomElem geo_appro(elem);
  xTensor2 stress;
  eval_stress(geo_appro,geo_appro,stress);
  value+=stress.vonMises();
  }
  

  field.setVal(e, val/nelem);
  v->point()(0)
  // iostream
  }


  };

