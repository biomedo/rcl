# -*- org -*-

# Time-stamp: <2010-12-05 16:59:23 Sunday by lian>

#+OPTIONS: ^:nil author:nil timestamp:nil creator:nil

* Useful Command
  - 

* How to launch external command
  ** 有两种方式可以调用外部程序：
    - 通过system命令，比如[status output] = system('/usr/bin/env bash --login -c ./main'),或者[status output] = system('pwd')等，可以调用系统中的命令
    - 通过！命令来调用，比如!pwd, !emacs ~/aa.txt, !ls -alh, !./main >>ouput.txt 2>>error.txt等。
  ** 小技巧
    - 通过在命令后面加入&，可以控制前台还是后台执行，比如!emacs ~/aa.txt &
    - 如果某个命令或者路径没有在matlab加载的环境变量中，可以更改环境变量path1 = getenv('PATH'); path1 = [path1 ':/usr/local/bin']; setenv('PATH', path1); !echo $PATH;
    - 当你调用一个外部程序时，matlab预先加载matlab路径下的预置的lib程序库，比如它会优先加载matlab/sys/os/glnx86/libstdc++.so.6。在这种情况下经常会出现你的程序所需要的版本和这个不一致，因此需要预先加载你的程序所需要的动态库的版本，比较简单的方案是按照上面修改环境变量的方法，增加一个环境变量，记住这种修改环境变量都是临时的，都是针对当前的session的，这样就不会影响系统的环境变量，比如你可以这样操作setenv LD_PRELOAD '/usr/lib/libstdc++.so.6', 如果有多个需要加载则用；分割，也就是setenv LD_PRELOAD '/lib/libgcc_s.so.1:/usr/lib/libstdc++.so.6.0.13:/lib/libz.so.1.2.3.3',这样在启动程序就可以正常启动了，并且matlab会等待程序运行结束，在继续执行剩下的matlab代码，也就是说在启动一个程序后matlab线程被阻塞了。
